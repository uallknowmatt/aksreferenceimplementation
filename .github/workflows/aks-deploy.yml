name: Deploy to AKS (Dev & Production)

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

# OIDC requires id-token: write permission
permissions:
  id-token: write  # Required for OIDC token generation
  contents: read   # Required to checkout code

env:
  IMAGE_TAG: ${{ github.sha }}
  TF_WORKING_DIR: ./infrastructure

jobs:
  # ============================================
  # JOB 0: Detect Changes
  # ============================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      infrastructure: ${{ steps.filter.outputs.infrastructure }}
      code: ${{ steps.filter.outputs.code }}
      k8s: ${{ steps.filter.outputs.k8s }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Check for file changes
        id: filter
        run: |
          echo "Checking for changes in different parts of the codebase..."
          
          # For workflow_dispatch, run everything
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger - will check all components"
            echo "infrastructure=true" >> $GITHUB_OUTPUT
            echo "code=true" >> $GITHUB_OUTPUT
            echo "k8s=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files
          if [ "${{ github.event.before }}" == "0000000000000000000000000000000000000000" ]; then
            # First push to branch
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r ${{ github.sha }})
          else
            CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
          fi
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check infrastructure changes
          if echo "$CHANGED_FILES" | grep -qE '^infrastructure/'; then
            echo "infrastructure=true" >> $GITHUB_OUTPUT
            echo "âœ“ Infrastructure changes detected"
          else
            echo "infrastructure=false" >> $GITHUB_OUTPUT
            echo "â—‹ No infrastructure changes"
          fi
          
          # Check code changes (microservices)
          if echo "$CHANGED_FILES" | grep -qE '^(customer-service|document-service|account-service|notification-service)/'; then
            echo "code=true" >> $GITHUB_OUTPUT
            echo "âœ“ Code changes detected"
          else
            echo "code=false" >> $GITHUB_OUTPUT
            echo "â—‹ No code changes"
          fi
          
          # Check k8s manifest changes
          if echo "$CHANGED_FILES" | grep -qE '^k8s/'; then
            echo "k8s=true" >> $GITHUB_OUTPUT
            echo "âœ“ Kubernetes manifest changes detected"
          else
            echo "k8s=false" >> $GITHUB_OUTPUT
            echo "â—‹ No Kubernetes manifest changes"
          fi

  # ============================================
  # JOB 1: Deploy Azure Infrastructure (DEV)
  # ============================================
  terraform-deploy-dev:
    name: Deploy Azure Infrastructure (Dev)
    needs: detect-changes
    if: needs.detect-changes.outputs.infrastructure == 'true'
    runs-on: ubuntu-latest
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC: true
      ENVIRONMENT: dev
    outputs:
      acr_login_server: ${{ steps.tf-output.outputs.acr_login_server }}
      acr_name: ${{ steps.tf-output.outputs.acr_name }}
      aks_cluster_name: ${{ steps.tf-output.outputs.aks_cluster_name }}
      aks_resource_group: ${{ steps.tf-output.outputs.aks_resource_group }}
      postgres_host: ${{ steps.tf-output.outputs.postgres_host }}
      managed_identity_client_id: ${{ steps.tf-output.outputs.managed_identity_client_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Setup Terraform State Backend
        run: |
          echo "ðŸ” Checking if Terraform state backend exists..."
          
          RESOURCE_GROUP="terraform-state-rg"
          STORAGE_ACCOUNT="tfstateaccountopening"
          CONTAINER="tfstate"
          LOCATION="eastus"
          
          # Check if storage account exists
          if az storage account show --name $STORAGE_ACCOUNT --resource-group $RESOURCE_GROUP &>/dev/null; then
            echo "âœ… Backend storage account already exists"
          else
            echo "ðŸ“¦ Creating Terraform state backend..."
            
            # Create resource group
            echo "Creating resource group: $RESOURCE_GROUP"
            az group create \
              --name $RESOURCE_GROUP \
              --location $LOCATION \
              --tags purpose=terraform-state managed_by=github-actions
            
            # Create storage account
            echo "Creating storage account: $STORAGE_ACCOUNT"
            az storage account create \
              --name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --location $LOCATION \
              --sku Standard_LRS \
              --kind StorageV2 \
              --https-only true \
              --min-tls-version TLS1_2 \
              --allow-blob-public-access false \
              --tags purpose=terraform-state managed_by=github-actions
            
            # Enable versioning
            echo "Enabling blob versioning..."
            az storage account blob-service-properties update \
              --account-name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --enable-versioning true
            
            # Create container
            echo "Creating blob container: $CONTAINER"
            az storage container create \
              --name $CONTAINER \
              --account-name $STORAGE_ACCOUNT \
              --auth-mode login
            
            # Enable soft delete
            echo "Enabling soft delete (30 days)..."
            az storage account blob-service-properties update \
              --account-name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --enable-delete-retention true \
              --delete-retention-days 30
            
            echo "âœ… Backend storage created successfully!"
          fi
          
          # Grant GitHub Actions service principal access to state storage
          echo "ðŸ” Ensuring service principal has storage access..."
          STORAGE_ACCOUNT_ID=$(az storage account show \
            --name $STORAGE_ACCOUNT \
            --resource-group $RESOURCE_GROUP \
            --query id -o tsv)
          
          SP_OBJECT_ID=$(az ad sp show \
            --id ${{ secrets.AZURE_CLIENT_ID }} \
            --query id -o tsv)
          
          # Check if role assignment exists, if not create it
          if ! az role assignment list \
            --assignee $SP_OBJECT_ID \
            --role "Storage Blob Data Contributor" \
            --scope $STORAGE_ACCOUNT_ID \
            --query "[0].id" -o tsv &>/dev/null; then
            
            echo "Granting Storage Blob Data Contributor role..."
            az role assignment create \
              --assignee $SP_OBJECT_ID \
              --role "Storage Blob Data Contributor" \
              --scope $STORAGE_ACCOUNT_ID
            echo "âœ… Role assigned successfully!"
          else
            echo "âœ… Service principal already has required role"
          fi

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Initializing Terraform with remote backend (dev environment)..."
          terraform init -reconfigure \
            -backend-config="key=dev.terraform.tfstate"

      - name: Clear Stuck State Locks (if any)
        working-directory: ${{ env.TF_WORKING_DIR }}
        continue-on-error: true
        run: |
          echo "Checking for stuck state locks..."
          
          # Check if blob is leased
          LEASE_STATE=$(az storage blob show \
            --account-name tfstateaccountopening \
            --container-name tfstate \
            --name dev.terraform.tfstate \
            --auth-mode login \
            --query "properties.lease.state" -o tsv 2>/dev/null || echo "unknown")
          
          echo "State file lease state: $LEASE_STATE"
          
          if [ "$LEASE_STATE" = "available" ]; then
            echo "âœ… No active lease - state is available"
            
            # Clear lock metadata if present but lease is free
            echo "Clearing any stale lock metadata..."
            az storage blob metadata update \
              --account-name tfstateaccountopening \
              --container-name tfstate \
              --name dev.terraform.tfstate \
              --auth-mode login \
              --metadata terraformlockid= 2>/dev/null || echo "No metadata to clear"
            
            echo "âœ… State lock cleared"
          else
            echo "âš ï¸  State has active lease: $LEASE_STATE"
            echo "Attempting to break lease..."
            az storage blob lease break \
              --account-name tfstateaccountopening \
              --container-name tfstate \
              --blob-name dev.terraform.tfstate \
              --auth-mode login \
              --lease-break-period 0 2>/dev/null || echo "Could not break lease"
          fi

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Validating Terraform configuration..."
          terraform validate

      - name: Check and Import Existing Resources
        working-directory: ${{ env.TF_WORKING_DIR }}
        continue-on-error: true
        run: |
          echo "=========================================="
          echo "Checking for existing resources to import"
          echo "=========================================="
          
          ENVIRONMENT="dev"
          LOCATION="eastus"
          PROJECT="account-opening"
          LOC_CODE="eus"
          
          # Resource names following locals.tf patterns
          RG_NAME="rg-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          ACR_NAME="acr$(echo $PROJECT | tr -d '-')${ENVIRONMENT}${LOC_CODE}"
          AKS_NAME="aks-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          VNET_NAME="vnet-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          POSTGRES_NAME="psql-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          LOG_NAME="log-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          IDENTITY_NAME="id-${PROJECT}-${ENVIRONMENT}-workload"
          NSG_NAME="${ENVIRONMENT}-aks-nsg"
          
          # Function to import resource if exists and not in state
          import_if_needed() {
            local RESOURCE_TYPE=$1
            local TERRAFORM_ADDRESS=$2
            local AZURE_NAME=$3
            local AZURE_COMMAND=$4
            
            echo ""
            echo "Checking: $RESOURCE_TYPE ($AZURE_NAME)"
            
            if eval "$AZURE_COMMAND" &>/dev/null; then
              echo "  âœ“ Resource exists in Azure"
              
              if terraform state list | grep -q "^${TERRAFORM_ADDRESS}$"; then
                echo "  âœ“ Already in Terraform state"
              else
                echo "  âš  Not in state - importing..."
                RESOURCE_ID=$(eval "$AZURE_COMMAND --query id -o tsv")
                echo "  ID: $RESOURCE_ID"
                
                if terraform import -var-file=environments/dev/terraform.tfvars \
                  "$TERRAFORM_ADDRESS" "$RESOURCE_ID" 2>&1 | tee /tmp/import.log; then
                  echo "  âœ“ Import successful"
                else
                  echo "  âœ— Import failed (continuing...)"
                  cat /tmp/import.log
                fi
              fi
            else
              echo "  â—‹ Does not exist (will be created)"
            fi
          }
          
          # Import all resources
          import_if_needed "Resource Group" \
            "azurerm_resource_group.rg" \
            "$RG_NAME" \
            "az group show --name $RG_NAME"
          
          import_if_needed "Virtual Network" \
            "azurerm_virtual_network.vnet" \
            "$VNET_NAME" \
            "az network vnet show --name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "AKS Subnet" \
            "azurerm_subnet.aks_subnet" \
            "aks-subnet" \
            "az network vnet subnet show --name aks-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "ACR Subnet" \
            "azurerm_subnet.acr_subnet" \
            "acr-subnet" \
            "az network vnet subnet show --name acr-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "Network Security Group" \
            "azurerm_network_security_group.aks_nsg" \
            "$NSG_NAME" \
            "az network nsg show --name $NSG_NAME --resource-group $RG_NAME"
          
          import_if_needed "NSG Association" \
            "azurerm_subnet_network_security_group_association.aks_nsg_assoc" \
            "aks-subnet-nsg" \
            "az network vnet subnet show --name aks-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME --query 'networkSecurityGroup.id'"
          
          import_if_needed "Log Analytics Workspace" \
            "azurerm_log_analytics_workspace.aks_logs" \
            "$LOG_NAME" \
            "az monitor log-analytics workspace show --workspace-name $LOG_NAME --resource-group $RG_NAME"
          
          import_if_needed "Container Registry" \
            "azurerm_container_registry.acr" \
            "$ACR_NAME" \
            "az acr show --name $ACR_NAME --resource-group $RG_NAME"
          
          import_if_needed "ACR Private Endpoint" \
            "azurerm_private_endpoint.acr_endpoint" \
            "pe-$ACR_NAME" \
            "az network private-endpoint show --name pe-$ACR_NAME --resource-group $RG_NAME"
          
          import_if_needed "PostgreSQL Server" \
            "azurerm_postgresql_flexible_server.db" \
            "$POSTGRES_NAME" \
            "az postgres flexible-server show --name $POSTGRES_NAME --resource-group $RG_NAME"
          
          import_if_needed "PostgreSQL Database: customerdb" \
            "azurerm_postgresql_flexible_server_database.customerdb" \
            "customerdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name customerdb"
          
          import_if_needed "PostgreSQL Database: documentdb" \
            "azurerm_postgresql_flexible_server_database.documentdb" \
            "documentdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name documentdb"
          
          import_if_needed "PostgreSQL Database: accountdb" \
            "azurerm_postgresql_flexible_server_database.accountdb" \
            "accountdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name accountdb"
          
          import_if_needed "PostgreSQL Database: notificationdb" \
            "azurerm_postgresql_flexible_server_database.notificationdb" \
            "notificationdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name notificationdb"
          
          import_if_needed "Workload Identity" \
            "azurerm_user_assigned_identity.workload_identity" \
            "$IDENTITY_NAME" \
            "az identity show --name $IDENTITY_NAME --resource-group $RG_NAME"
          
          import_if_needed "AKS Cluster" \
            "azurerm_kubernetes_cluster.aks" \
            "$AKS_NAME" \
            "az aks show --name $AKS_NAME --resource-group $RG_NAME"
          
          # Note: Some resources like role assignments and federated credentials
          # are harder to check/import, so we let Terraform handle them
          
          echo ""
          echo "=========================================="
          echo "âœ“ Resource import check complete"
          echo "=========================================="

      - name: Wait for PostgreSQL Deletion (if in progress)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Checking if PostgreSQL server is being deleted..."
          POSTGRES_NAME="psql-account-opening-dev-eus"
          RG_NAME="rg-account-opening-dev-eus"
          
          # Check if server exists and its state
          if az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" &>/dev/null; then
            STATE=$(az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" --query "state" -o tsv 2>/dev/null || echo "NotFound")
            
            if [ "$STATE" = "Dropping" ]; then
              echo "âš ï¸  PostgreSQL server is being deleted (State: Dropping)"
              echo "Waiting for deletion to complete (max 10 minutes)..."
              
              for i in {1..60}; do
                sleep 10
                if ! az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" &>/dev/null; then
                  echo "âœ… PostgreSQL server deleted successfully"
                  break
                fi
                
                CURRENT_STATE=$(az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" --query "state" -o tsv 2>/dev/null || echo "NotFound")
                if [ "$CURRENT_STATE" != "Dropping" ]; then
                  echo "âœ… PostgreSQL server state changed to: $CURRENT_STATE"
                  break
                fi
                
                echo "  Still dropping... (${i}0 seconds elapsed)"
              done
            else
              echo "PostgreSQL server state: $STATE"
            fi
          else
            echo "âœ… No existing PostgreSQL server found (or already deleted)"
          fi

      - name: Terraform Plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Creating Terraform plan for dev environment..."
          
          # Retry logic for state lock conflicts
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            
            if terraform plan -var-file=environments/dev/terraform.tfvars -out=tfplan; then
              echo "âœ… Terraform plan succeeded"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 30))
              echo "âš ï¸  Plan failed, waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            fi
          done
          
          echo "âŒ Terraform plan failed after $MAX_RETRIES attempts"
          exit 1
          
      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Applying Terraform configuration..."
          terraform apply -auto-approve tfplan
          echo "âœ… Infrastructure created successfully!"

      - name: Get Terraform Outputs
        id: tf-output
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Reading Terraform outputs..."
          
          # Get outputs from created infrastructure
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_NAME=$(terraform output -raw acr_name)
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw aks_resource_group_name)
          POSTGRES_HOST=$(terraform output -raw postgres_fqdn)
          MANAGED_IDENTITY_CLIENT_ID=$(terraform output -raw workload_identity_client_id)
          
          echo "ðŸ“¦ ACR: $ACR_LOGIN_SERVER"
          echo "â˜¸ï¸  AKS: $AKS_CLUSTER_NAME"
          echo "ðŸ—„ï¸  PostgreSQL: $POSTGRES_HOST"
          
          # Set as job outputs
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "aks_resource_group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "managed_identity_client_id=$MANAGED_IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 2: Build and Push Docker Images (DEV)
  # ============================================
  build-and-push-dev:
    name: Build and Push Images (Dev)
    needs: [detect-changes, terraform-deploy-dev]
    if: |
      always() &&
      needs.detect-changes.outputs.code == 'true' &&
      (needs.terraform-deploy-dev.result == 'success' || needs.terraform-deploy-dev.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      acr_login_server: ${{ steps.get-acr.outputs.acr_login_server }}
      acr_name: ${{ steps.get-acr.outputs.acr_name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get ACR information
        id: get-acr
        run: |
          # Determine location code from terraform.tfvars
          LOCATION=$(grep '^location' infrastructure/environments/dev/terraform.tfvars | awk -F'"' '{print $2}')
          case "$LOCATION" in
            "eastus") LOC_CODE="eus" ;;
            "eastus2") LOC_CODE="eus2" ;;
            "westus") LOC_CODE="wus" ;;
            "westus2") LOC_CODE="wus2" ;;
            "centralus") LOC_CODE="cus" ;;
            *) LOC_CODE="eus2" ;;
          esac
          
          PROJECT="account-opening"
          ENV="dev"
          RG_NAME="rg-${PROJECT}-${ENV}-${LOC_CODE}"
          ACR_NAME="acr$(echo $PROJECT | tr -d '-')${ENV}${LOC_CODE}"
          
          # Get ACR info from Terraform outputs or from existing resources
          if [ "${{ needs.terraform-deploy-dev.result }}" == "success" ]; then
            echo "âœ“ Using ACR info from Terraform outputs"
            echo "acr_login_server=${{ needs.terraform-deploy-dev.outputs.acr_login_server }}" >> $GITHUB_OUTPUT
            echo "acr_name=${{ needs.terraform-deploy-dev.outputs.acr_name }}" >> $GITHUB_OUTPUT
          else
            echo "âœ“ Getting ACR info from Azure (infrastructure not updated)"
            ACR_LOGIN_SERVER=$(az acr show --name $ACR_NAME --resource-group $RG_NAME --query loginServer -o tsv)
            echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
            echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          fi

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build microservices with Maven
        run: |
          echo "Building microservices..."
          mvn clean package -DskipTests
          echo "âœ… Maven build complete!"

      - name: Log in to Azure Container Registry
        run: |
          echo "Logging into ACR: ${{ steps.get-acr.outputs.acr_name }}"
          az acr login --name ${{ steps.get-acr.outputs.acr_name }}
          echo "âœ… Logged into ACR!"

      - name: Build and push Docker images
        env:
          ACR_LOGIN_SERVER: ${{ steps.get-acr.outputs.acr_login_server }}
        run: |
          echo "Building Docker images..."
          
          # Customer Service
          echo "Building customer-service..."
          docker build -t $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG ./customer-service
          docker push $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG
          
          # Document Service
          echo "Building document-service..."
          docker build -t $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG ./document-service
          docker push $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG
          
          # Account Service
          echo "Building account-service..."
          docker build -t $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG ./account-service
          docker push $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG
          
          # Notification Service
          echo "Building notification-service..."
          docker build -t $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG ./notification-service
          docker push $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG
          
          echo "âœ… All images pushed to ACR!"

  # ============================================
  # JOB 3: Deploy to AKS (DEV)
  # ============================================
  deploy-to-aks-dev:
    name: Deploy to AKS (Dev)
    needs: [detect-changes, terraform-deploy-dev, build-and-push-dev]
    if: |
      always() &&
      (
        github.event_name == 'workflow_dispatch' ||
        needs.detect-changes.outputs.code == 'true' ||
        needs.detect-changes.outputs.k8s == 'true'
      ) &&
      (needs.terraform-deploy-dev.result == 'success' || needs.terraform-deploy-dev.result == 'skipped') &&
      (needs.build-and-push-dev.result == 'success' || needs.build-and-push-dev.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get deployment info
        id: get-info
        run: |
          # Determine location code from terraform.tfvars
          LOCATION=$(grep '^location' infrastructure/environments/dev/terraform.tfvars | awk -F'"' '{print $2}')
          echo "Location from tfvars: $LOCATION"
          
          # Map location to short code
          case "$LOCATION" in
            "eastus") LOC_CODE="eus" ;;
            "eastus2") LOC_CODE="eus2" ;;
            "westus") LOC_CODE="wus" ;;
            "westus2") LOC_CODE="wus2" ;;
            "centralus") LOC_CODE="cus" ;;
            *) LOC_CODE="eus2" ;;
          esac
          
          echo "Location code: $LOC_CODE"
          
          # Build resource names
          PROJECT="account-opening"
          ENV="dev"
          RG_NAME="rg-${PROJECT}-${ENV}-${LOC_CODE}"
          AKS_NAME="aks-${PROJECT}-${ENV}-${LOC_CODE}"
          ACR_NAME="acr$(echo $PROJECT | tr -d '-')${ENV}${LOC_CODE}"
          POSTGRES_NAME="psql-${PROJECT}-${ENV}-${LOC_CODE}"
          IDENTITY_NAME="id-${PROJECT}-${ENV}-workload"
          
          echo "Resource Group: $RG_NAME"
          echo "AKS Cluster: $AKS_NAME"
          echo "ACR Name: $ACR_NAME"
          
          # Get info from Terraform outputs or from existing resources
          if [ "${{ needs.terraform-deploy-dev.result }}" == "success" ]; then
            echo "âœ“ Using info from Terraform outputs"
            echo "acr_login_server=${{ needs.terraform-deploy-dev.outputs.acr_login_server }}" >> $GITHUB_OUTPUT
            echo "aks_cluster_name=${{ needs.terraform-deploy-dev.outputs.aks_cluster_name }}" >> $GITHUB_OUTPUT
            echo "aks_resource_group=${{ needs.terraform-deploy-dev.outputs.aks_resource_group }}" >> $GITHUB_OUTPUT
            echo "postgres_host=${{ needs.terraform-deploy-dev.outputs.postgres_host }}" >> $GITHUB_OUTPUT
            echo "managed_identity_client_id=${{ needs.terraform-deploy-dev.outputs.managed_identity_client_id }}" >> $GITHUB_OUTPUT
          elif [ "${{ needs.build-and-push-dev.result }}" == "success" ]; then
            echo "âœ“ Using ACR info from build job and fetching other info from Azure"
            ACR_LOGIN_SERVER="${{ needs.build-and-push-dev.outputs.acr_login_server }}"
            POSTGRES_HOST=$(az postgres flexible-server show --name $POSTGRES_NAME --resource-group $RG_NAME --query fullyQualifiedDomainName -o tsv)
            IDENTITY_CLIENT_ID=$(az identity show --name $IDENTITY_NAME --resource-group $RG_NAME --query clientId -o tsv)
            
            echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
            echo "aks_cluster_name=$AKS_NAME" >> $GITHUB_OUTPUT
            echo "aks_resource_group=$RG_NAME" >> $GITHUB_OUTPUT
            echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
            echo "managed_identity_client_id=$IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT
          else
            echo "âœ“ Fetching all info from Azure (k8s-only changes)"
            
            # Check if resource group exists
            if ! az group show --name "$RG_NAME" &>/dev/null; then
              echo "âŒ Error: Infrastructure not yet deployed!"
              echo "   Resource group '$RG_NAME' does not exist."
              echo "   Please run workflow manually or push infrastructure changes first."
              exit 1
            fi
            
            ACR_LOGIN_SERVER=$(az acr show --name $ACR_NAME --resource-group $RG_NAME --query loginServer -o tsv)
            POSTGRES_HOST=$(az postgres flexible-server show --name $POSTGRES_NAME --resource-group $RG_NAME --query fullyQualifiedDomainName -o tsv)
            IDENTITY_CLIENT_ID=$(az identity show --name $IDENTITY_NAME --resource-group $RG_NAME --query clientId -o tsv)
            
            echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
            echo "aks_cluster_name=$AKS_NAME" >> $GITHUB_OUTPUT
            echo "aks_resource_group=$RG_NAME" >> $GITHUB_OUTPUT
            echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
            echo "managed_identity_client_id=$IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT
          fi

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          cluster-name: ${{ steps.get-info.outputs.aks_cluster_name }}
          resource-group: ${{ steps.get-info.outputs.aks_resource_group }}

      - name: Replace placeholders in k8s manifests
        env:
          ACR_LOGIN_SERVER: ${{ steps.get-info.outputs.acr_login_server }}
          POSTGRES_HOST: ${{ steps.get-info.outputs.postgres_host }}
          MANAGED_IDENTITY_CLIENT_ID: ${{ steps.get-info.outputs.managed_identity_client_id }}
        run: |
          echo "Updating Kubernetes manifests..."
          
          # Replace ACR and image tags
          sed -i "s|<ACR_LOGIN_SERVER>|$ACR_LOGIN_SERVER|g" k8s/*.yaml
          sed -i "s|<TAG>|$IMAGE_TAG|g" k8s/*.yaml
          
          # Replace managed identity for workload identity
          sed -i "s|<MANAGED_IDENTITY_CLIENT_ID>|$MANAGED_IDENTITY_CLIENT_ID|g" k8s/*.yaml
          
          # Replace postgres host (no passwords - using managed identity!)
          sed -i "s|<POSTGRES_HOST>|$POSTGRES_HOST|g" k8s/*.yaml
          
          echo "âœ… Manifests updated!"

      - name: Deploy ConfigMaps and Secrets
        run: |
          echo "Deploying ConfigMaps and Secrets..."
          kubectl apply -f k8s/customer-service-configmap.yaml
          kubectl apply -f k8s/document-service-configmap.yaml
          kubectl apply -f k8s/account-service-configmap.yaml
          kubectl apply -f k8s/notification-service-configmap.yaml
          kubectl apply -f k8s/customer-service-secret.yaml
          kubectl apply -f k8s/document-service-secret.yaml
          kubectl apply -f k8s/account-service-secret.yaml
          kubectl apply -f k8s/notification-service-secret.yaml
          echo "âœ… ConfigMaps and Secrets deployed!"

      - name: Deploy Services
        run: |
          echo "Deploying Kubernetes Services..."
          kubectl apply -f k8s/customer-service-service.yaml
          kubectl apply -f k8s/document-service-service.yaml
          kubectl apply -f k8s/account-service-service.yaml
          kubectl apply -f k8s/notification-service-service.yaml
          echo "âœ… Services deployed!"

      - name: Deploy Applications
        run: |
          echo "Deploying applications to AKS..."
          kubectl apply -f k8s/customer-service-deployment.yaml
          kubectl apply -f k8s/document-service-deployment.yaml
          kubectl apply -f k8s/account-service-deployment.yaml
          kubectl apply -f k8s/notification-service-deployment.yaml
          echo "âœ… Applications deployed!"

      - name: Wait for deployments to be ready
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/customer-service --timeout=300s
          kubectl rollout status deployment/document-service --timeout=300s
          kubectl rollout status deployment/account-service --timeout=300s
          kubectl rollout status deployment/notification-service --timeout=300s
          echo "âœ… All deployments ready!"

      - name: Get Service Information
        run: |
          echo "=========================================="
          echo "Deployment Summary (Dev)"
          echo "=========================================="
          echo ""
          echo "ðŸ“¦ Pods:"
          kubectl get pods -o wide
          echo ""
          echo "ðŸŒ Services:"
          kubectl get services -o wide
          echo ""
          echo "âœ… Dev deployment complete!"

  # ============================================
  # JOB 4: Infrastructure Decision Gate
  # ============================================
  infrastructure-decision:
    name: Keep or Destroy Infrastructure?
    needs: [deploy-to-aks-dev]
    if: always() && needs.deploy-to-aks-dev.result == 'success'
    runs-on: ubuntu-latest
    environment:
      name: infrastructure-decision
    outputs:
      action: ${{ steps.decision.outputs.action }}
    steps:
      - name: Infrastructure Decision
        id: decision
        run: |
          echo "=========================================="
          echo "ðŸ’° INFRASTRUCTURE COST DECISION"
          echo "=========================================="
          echo ""
          echo "âœ… Development environment deployed successfully!"
          echo ""
          echo "ðŸ” Current resources running:"
          echo "   - AKS Cluster (2 nodes, Standard_DS2_v2)"
          echo "   - PostgreSQL Flexible Server (Burstable B1ms)"
          echo "   - Azure Container Registry (Basic tier)"
          echo "   - Log Analytics Workspace"
          echo "   - Virtual Network & NSG"
          echo ""
          echo "ðŸ’µ Estimated cost: ~$150-200/month if left running"
          echo ""
          echo "âš ï¸  CHOOSE YOUR ACTION:"
          echo ""
          echo "Option 1: APPROVE THIS STEP"
          echo "  â†’ Continue to production deployment"
          echo "  â†’ Infrastructure remains running"
          echo "  â†’ Costs will continue to accrue"
          echo ""
          echo "Option 2: CANCEL THIS WORKFLOW"
          echo "  â†’ Trigger the destroy workflow manually"
          echo "  â†’ Run: gh workflow run 'Destroy Infrastructure'"
          echo "  â†’ All resources will be deleted"
          echo "  â†’ Costs reduced to ~$0.02/month (state storage only)"
          echo ""
          echo "action=continue" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 5: UAT Test Complete (Manual Approval Gate)
  # ============================================
  uat-test-complete:
    name: UAT Testing Complete - Approve for Production
    needs: [infrastructure-decision]
    if: needs.infrastructure-decision.outputs.action == 'continue'
    runs-on: ubuntu-latest
    environment:
      name: production-approval
    steps:
      - name: Manual Approval Required
        run: |
          echo "=========================================="
          echo "ðŸŽ¯ UAT TESTING COMPLETE"
          echo "=========================================="
          echo ""
          echo "âœ… Development environment deployed successfully"
          echo "âœ… Ready for production deployment"
          echo ""
          echo "âš ï¸  Production deployment will begin after manual approval"
          echo "âš ï¸  Please verify UAT testing is complete before approving"
          echo ""
          echo "To approve:"
          echo "1. Review the dev deployment results"
          echo "2. Complete UAT testing"
          echo "3. Approve this workflow in GitHub Actions UI"
          echo ""

  # ============================================
  # JOB 6: Deploy Azure Infrastructure (PROD)
  # ============================================
  terraform-deploy-prod:
    name: Deploy Azure Infrastructure (Prod)
    needs: [uat-test-complete]
    runs-on: ubuntu-latest
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC: true
      ENVIRONMENT: prod
    outputs:
      acr_login_server: ${{ steps.tf-output.outputs.acr_login_server }}
      acr_name: ${{ steps.tf-output.outputs.acr_name }}
      aks_cluster_name: ${{ steps.tf-output.outputs.aks_cluster_name }}
      aks_resource_group: ${{ steps.tf-output.outputs.aks_resource_group }}
      postgres_host: ${{ steps.tf-output.outputs.postgres_host }}
      managed_identity_client_id: ${{ steps.tf-output.outputs.managed_identity_client_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Setup Terraform State Backend
        run: |
          echo "ðŸ” Checking if Terraform state backend exists..."
          
          RESOURCE_GROUP="terraform-state-rg"
          STORAGE_ACCOUNT="tfstateaccountopening"
          CONTAINER="tfstate"
          LOCATION="eastus"
          
          if az storage account show --name $STORAGE_ACCOUNT --resource-group $RESOURCE_GROUP &>/dev/null; then
            echo "âœ… Backend storage account already exists"
          else
            echo "ðŸ“¦ Creating Terraform state backend..."
            
            az group create \
              --name $RESOURCE_GROUP \
              --location $LOCATION \
              --tags purpose=terraform-state managed_by=github-actions
            
            az storage account create \
              --name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --location $LOCATION \
              --sku Standard_LRS \
              --kind StorageV2 \
              --https-only true \
              --min-tls-version TLS1_2 \
              --allow-blob-public-access false \
              --tags purpose=terraform-state managed_by=github-actions
            
            az storage account blob-service-properties update \
              --account-name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --enable-versioning true
            
            az storage container create \
              --name $CONTAINER \
              --account-name $STORAGE_ACCOUNT \
              --auth-mode login
            
            az storage account blob-service-properties update \
              --account-name $STORAGE_ACCOUNT \
              --resource-group $RESOURCE_GROUP \
              --enable-delete-retention true \
              --delete-retention-days 30
            
            echo "âœ… Backend storage created successfully!"
          fi
          
          echo "ðŸ” Ensuring service principal has storage access..."
          STORAGE_ACCOUNT_ID=$(az storage account show \
            --name $STORAGE_ACCOUNT \
            --resource-group $RESOURCE_GROUP \
            --query id -o tsv)
          
          SP_OBJECT_ID=$(az ad sp show \
            --id ${{ secrets.AZURE_CLIENT_ID }} \
            --query id -o tsv)
          
          if ! az role assignment list \
            --assignee $SP_OBJECT_ID \
            --role "Storage Blob Data Contributor" \
            --scope $STORAGE_ACCOUNT_ID \
            --query "[0].id" -o tsv &>/dev/null; then
            
            echo "Granting Storage Blob Data Contributor role..."
            az role assignment create \
              --assignee $SP_OBJECT_ID \
              --role "Storage Blob Data Contributor" \
              --scope $STORAGE_ACCOUNT_ID
            echo "âœ… Role assigned successfully!"
          else
            echo "âœ… Service principal already has required role"
          fi

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Initializing Terraform with remote backend (prod environment)..."
          terraform init -reconfigure \
            -backend-config="key=prod.terraform.tfstate"

      - name: Clear Stuck State Locks (if any)
        working-directory: ${{ env.TF_WORKING_DIR }}
        continue-on-error: true
        run: |
          echo "Checking for stuck state locks..."
          
          # Check if blob is leased
          LEASE_STATE=$(az storage blob show \
            --account-name tfstateaccountopening \
            --container-name tfstate \
            --name prod.terraform.tfstate \
            --auth-mode login \
            --query "properties.lease.state" -o tsv 2>/dev/null || echo "unknown")
          
          echo "State file lease state: $LEASE_STATE"
          
          if [ "$LEASE_STATE" = "available" ]; then
            echo "âœ… No active lease - state is available"
            
            # Clear lock metadata if present but lease is free
            echo "Clearing any stale lock metadata..."
            az storage blob metadata update \
              --account-name tfstateaccountopening \
              --container-name tfstate \
              --name prod.terraform.tfstate \
              --auth-mode login \
              --metadata terraformlockid= 2>/dev/null || echo "No metadata to clear"
            
            echo "âœ… State lock cleared"
          else
            echo "âš ï¸  State has active lease: $LEASE_STATE"
            echo "Attempting to break lease..."
            az storage blob lease break \
              --account-name tfstateaccountopening \
              --container-name tfstate \
              --blob-name prod.terraform.tfstate \
              --auth-mode login \
              --lease-break-period 0 2>/dev/null || echo "Could not break lease"
          fi

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Validating Terraform configuration..."
          terraform validate

      - name: Check and Import Existing Resources
        working-directory: ${{ env.TF_WORKING_DIR }}
        continue-on-error: true
        run: |
          echo "=========================================="
          echo "Checking for existing production resources"
          echo "=========================================="
          
          ENVIRONMENT="prod"
          LOCATION="eastus"
          PROJECT="account-opening"
          LOC_CODE="eus"
          
          RG_NAME="rg-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          ACR_NAME="acr$(echo $PROJECT | tr -d '-')${ENVIRONMENT}${LOC_CODE}"
          AKS_NAME="aks-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          VNET_NAME="vnet-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          POSTGRES_NAME="psql-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          LOG_NAME="log-${PROJECT}-${ENVIRONMENT}-${LOC_CODE}"
          IDENTITY_NAME="id-${PROJECT}-${ENVIRONMENT}-workload"
          NSG_NAME="${ENVIRONMENT}-aks-nsg"
          
          import_if_needed() {
            local RESOURCE_TYPE=$1
            local TERRAFORM_ADDRESS=$2
            local AZURE_NAME=$3
            local AZURE_COMMAND=$4
            
            echo ""
            echo "Checking: $RESOURCE_TYPE ($AZURE_NAME)"
            
            if eval "$AZURE_COMMAND" &>/dev/null; then
              echo "  âœ“ Resource exists in Azure"
              
              if terraform state list | grep -q "^${TERRAFORM_ADDRESS}$"; then
                echo "  âœ“ Already in Terraform state"
              else
                echo "  âš  Not in state - importing..."
                RESOURCE_ID=$(eval "$AZURE_COMMAND --query id -o tsv")
                echo "  ID: $RESOURCE_ID"
                
                if terraform import -var-file=environments/prod/terraform.tfvars \
                  "$TERRAFORM_ADDRESS" "$RESOURCE_ID" 2>&1 | tee /tmp/import.log; then
                  echo "  âœ“ Import successful"
                else
                  echo "  âœ— Import failed (continuing...)"
                  cat /tmp/import.log
                fi
              fi
            else
              echo "  â—‹ Does not exist (will be created)"
            fi
          }
          
          import_if_needed "Resource Group" \
            "azurerm_resource_group.rg" \
            "$RG_NAME" \
            "az group show --name $RG_NAME"
          
          import_if_needed "Virtual Network" \
            "azurerm_virtual_network.vnet" \
            "$VNET_NAME" \
            "az network vnet show --name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "AKS Subnet" \
            "azurerm_subnet.aks_subnet" \
            "aks-subnet" \
            "az network vnet subnet show --name aks-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "ACR Subnet" \
            "azurerm_subnet.acr_subnet" \
            "acr-subnet" \
            "az network vnet subnet show --name acr-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME"
          
          import_if_needed "Network Security Group" \
            "azurerm_network_security_group.aks_nsg" \
            "$NSG_NAME" \
            "az network nsg show --name $NSG_NAME --resource-group $RG_NAME"
          
          import_if_needed "NSG Association" \
            "azurerm_subnet_network_security_group_association.aks_nsg_assoc" \
            "aks-subnet-nsg" \
            "az network vnet subnet show --name aks-subnet --vnet-name $VNET_NAME --resource-group $RG_NAME --query 'networkSecurityGroup.id'"
          
          import_if_needed "Log Analytics Workspace" \
            "azurerm_log_analytics_workspace.aks_logs" \
            "$LOG_NAME" \
            "az monitor log-analytics workspace show --workspace-name $LOG_NAME --resource-group $RG_NAME"
          
          import_if_needed "Container Registry" \
            "azurerm_container_registry.acr" \
            "$ACR_NAME" \
            "az acr show --name $ACR_NAME --resource-group $RG_NAME"
          
          import_if_needed "ACR Private Endpoint" \
            "azurerm_private_endpoint.acr_endpoint" \
            "pe-$ACR_NAME" \
            "az network private-endpoint show --name pe-$ACR_NAME --resource-group $RG_NAME"
          
          import_if_needed "PostgreSQL Server" \
            "azurerm_postgresql_flexible_server.db" \
            "$POSTGRES_NAME" \
            "az postgres flexible-server show --name $POSTGRES_NAME --resource-group $RG_NAME"
          
          import_if_needed "PostgreSQL Database: customerdb" \
            "azurerm_postgresql_flexible_server_database.customerdb" \
            "customerdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name customerdb"
          
          import_if_needed "PostgreSQL Database: documentdb" \
            "azurerm_postgresql_flexible_server_database.documentdb" \
            "documentdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name documentdb"
          
          import_if_needed "PostgreSQL Database: accountdb" \
            "azurerm_postgresql_flexible_server_database.accountdb" \
            "accountdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name accountdb"
          
          import_if_needed "PostgreSQL Database: notificationdb" \
            "azurerm_postgresql_flexible_server_database.notificationdb" \
            "notificationdb" \
            "az postgres flexible-server db show --server-name $POSTGRES_NAME --resource-group $RG_NAME --database-name notificationdb"
          
          import_if_needed "Workload Identity" \
            "azurerm_user_assigned_identity.workload_identity" \
            "$IDENTITY_NAME" \
            "az identity show --name $IDENTITY_NAME --resource-group $RG_NAME"
          
          import_if_needed "AKS Cluster" \
            "azurerm_kubernetes_cluster.aks" \
            "$AKS_NAME" \
            "az aks show --name $AKS_NAME --resource-group $RG_NAME"
          
          echo ""
          echo "=========================================="
          echo "âœ“ Resource import check complete"
          echo "=========================================="

      - name: Wait for PostgreSQL Deletion (if in progress)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Checking if PostgreSQL server is being deleted..."
          POSTGRES_NAME="psql-account-opening-prod-eus"
          RG_NAME="rg-account-opening-prod-eus"
          
          # Check if server exists and its state
          if az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" &>/dev/null; then
            STATE=$(az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" --query "state" -o tsv 2>/dev/null || echo "NotFound")
            
            if [ "$STATE" = "Dropping" ]; then
              echo "âš ï¸  PostgreSQL server is being deleted (State: Dropping)"
              echo "Waiting for deletion to complete (max 10 minutes)..."
              
              for i in {1..60}; do
                sleep 10
                if ! az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" &>/dev/null; then
                  echo "âœ… PostgreSQL server deleted successfully"
                  break
                fi
                
                CURRENT_STATE=$(az postgres flexible-server show --name "$POSTGRES_NAME" --resource-group "$RG_NAME" --query "state" -o tsv 2>/dev/null || echo "NotFound")
                if [ "$CURRENT_STATE" != "Dropping" ]; then
                  echo "âœ… PostgreSQL server state changed to: $CURRENT_STATE"
                  break
                fi
                
                echo "  Still dropping... (${i}0 seconds elapsed)"
              done
            else
              echo "PostgreSQL server state: $STATE"
            fi
          else
            echo "âœ… No existing PostgreSQL server found (or already deleted)"
          fi

      - name: Terraform Plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Creating Terraform plan for prod environment..."
          
          # Retry logic for state lock conflicts
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            
            if terraform plan -var-file=environments/prod/terraform.tfvars -out=tfplan; then
              echo "âœ… Terraform plan succeeded"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              WAIT_TIME=$((RETRY_COUNT * 30))
              echo "âš ï¸  Plan failed, waiting ${WAIT_TIME} seconds before retry..."
              sleep $WAIT_TIME
            fi
          done
          
          echo "âŒ Terraform plan failed after $MAX_RETRIES attempts"
          exit 1
          
      - name: Production Deployment Warning
        run: |
          echo "=========================================="
          echo "âš ï¸  PRODUCTION DEPLOYMENT WARNING"
          echo "=========================================="
          echo ""
          echo "You are about to deploy to PRODUCTION"
          echo "This will affect the live environment"
          echo ""
          echo "Waiting 10 seconds before proceeding..."
          sleep 10

      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Applying Terraform configuration to production..."
          terraform apply -auto-approve tfplan
          echo "âœ… Production infrastructure created successfully!"

      - name: Get Terraform Outputs
        id: tf-output
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Reading Terraform outputs..."
          
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_NAME=$(terraform output -raw acr_name)
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw aks_resource_group_name)
          POSTGRES_HOST=$(terraform output -raw postgres_fqdn)
          MANAGED_IDENTITY_CLIENT_ID=$(terraform output -raw workload_identity_client_id)
          
          echo "ðŸ“¦ ACR: $ACR_LOGIN_SERVER"
          echo "â˜¸ï¸  AKS: $AKS_CLUSTER_NAME"
          echo "ðŸ—„ï¸  PostgreSQL: $POSTGRES_HOST"
          
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "aks_resource_group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "managed_identity_client_id=$MANAGED_IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 7: Build and Push Docker Images (PROD)
  # ============================================
  build-and-push-prod:
    name: Build and Push Images (Prod)
    needs: terraform-deploy-prod
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build microservices with Maven
        run: |
          echo "Building microservices for production..."
          mvn clean package -DskipTests
          echo "âœ… Maven build complete!"

      - name: Log in to Azure Container Registry
        run: |
          echo "Logging into ACR: ${{ needs.terraform-deploy-prod.outputs.acr_name }}"
          az acr login --name ${{ needs.terraform-deploy-prod.outputs.acr_name }}
          echo "âœ… Logged into ACR!"

      - name: Build and push Docker images
        env:
          ACR_LOGIN_SERVER: ${{ needs.terraform-deploy-prod.outputs.acr_login_server }}
        run: |
          echo "Building Docker images for production..."
          
          docker build -t $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG ./customer-service
          docker push $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG
          
          docker build -t $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG ./document-service
          docker push $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG
          
          docker build -t $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG ./account-service
          docker push $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG
          
          docker build -t $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG ./notification-service
          docker push $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG
          
          echo "âœ… All production images pushed to ACR!"

  # ============================================
  # JOB 8: Deploy to AKS (PROD)
  # ============================================
  deploy-to-aks-prod:
    name: Deploy to AKS (Prod)
    needs: [terraform-deploy-prod, build-and-push-prod]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          cluster-name: ${{ needs.terraform-deploy-prod.outputs.aks_cluster_name }}
          resource-group: ${{ needs.terraform-deploy-prod.outputs.aks_resource_group }}

      - name: Replace placeholders in k8s manifests
        env:
          ACR_LOGIN_SERVER: ${{ needs.terraform-deploy-prod.outputs.acr_login_server }}
          POSTGRES_HOST: ${{ needs.terraform-deploy-prod.outputs.postgres_host }}
          MANAGED_IDENTITY_CLIENT_ID: ${{ needs.terraform-deploy-prod.outputs.managed_identity_client_id }}
        run: |
          echo "Updating Kubernetes manifests for production..."
          
          sed -i "s|<ACR_LOGIN_SERVER>|$ACR_LOGIN_SERVER|g" k8s/*.yaml
          sed -i "s|<TAG>|$IMAGE_TAG|g" k8s/*.yaml
          sed -i "s|<MANAGED_IDENTITY_CLIENT_ID>|$MANAGED_IDENTITY_CLIENT_ID|g" k8s/*.yaml
          sed -i "s|<POSTGRES_HOST>|$POSTGRES_HOST|g" k8s/*.yaml
          
          echo "âœ… Manifests updated!"

      - name: Deploy ConfigMaps and Secrets
        run: |
          echo "Deploying ConfigMaps and Secrets to production..."
          kubectl apply -f k8s/customer-service-configmap.yaml
          kubectl apply -f k8s/document-service-configmap.yaml
          kubectl apply -f k8s/account-service-configmap.yaml
          kubectl apply -f k8s/notification-service-configmap.yaml
          kubectl apply -f k8s/customer-service-secret.yaml
          kubectl apply -f k8s/document-service-secret.yaml
          kubectl apply -f k8s/account-service-secret.yaml
          kubectl apply -f k8s/notification-service-secret.yaml
          echo "âœ… ConfigMaps and Secrets deployed!"

      - name: Deploy Services
        run: |
          echo "Deploying Kubernetes Services to production..."
          kubectl apply -f k8s/customer-service-service.yaml
          kubectl apply -f k8s/document-service-service.yaml
          kubectl apply -f k8s/account-service-service.yaml
          kubectl apply -f k8s/notification-service-service.yaml
          echo "âœ… Services deployed!"

      - name: Deploy Applications
        run: |
          echo "Deploying applications to production AKS..."
          kubectl apply -f k8s/customer-service-deployment.yaml
          kubectl apply -f k8s/document-service-deployment.yaml
          kubectl apply -f k8s/account-service-deployment.yaml
          kubectl apply -f k8s/notification-service-deployment.yaml
          echo "âœ… Applications deployed!"

      - name: Wait for deployments to be ready
        run: |
          echo "Waiting for production deployments to be ready..."
          kubectl rollout status deployment/customer-service --timeout=300s
          kubectl rollout status deployment/document-service --timeout=300s
          kubectl rollout status deployment/account-service --timeout=300s
          kubectl rollout status deployment/notification-service --timeout=300s
          echo "âœ… All deployments ready!"

      - name: Get Service Information
        run: |
          echo "=========================================="
          echo "Production Deployment Summary"
          echo "=========================================="
          echo ""
          echo "ðŸ“¦ Pods:"
          kubectl get pods -o wide
          echo ""
          echo "ðŸŒ Services:"
          kubectl get services -o wide
          echo ""
          echo "âœ… Production deployment complete!"
