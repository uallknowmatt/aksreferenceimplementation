name: Deploy to AKS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

# OIDC requires id-token: write permission
permissions:
  id-token: write  # Required for OIDC token generation
  contents: read   # Required to checkout code

env:
  IMAGE_TAG: ${{ github.sha }}
  TF_WORKING_DIR: ./infrastructure
  ENVIRONMENT: dev

jobs:
  # ============================================
  # JOB 1: Deploy Azure Infrastructure
  # ============================================
  terraform-deploy:
    name: Deploy Azure Infrastructure
    runs-on: ubuntu-latest
    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC: true
    outputs:
      acr_login_server: ${{ steps.tf-output.outputs.acr_login_server }}
      acr_name: ${{ steps.tf-output.outputs.acr_name }}
      aks_cluster_name: ${{ steps.tf-output.outputs.aks_cluster_name }}
      aks_resource_group: ${{ steps.tf-output.outputs.aks_resource_group }}
      postgres_host: ${{ steps.tf-output.outputs.postgres_host }}
      managed_identity_client_id: ${{ steps.tf-output.outputs.managed_identity_client_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Initializing Terraform..."
          terraform init

      - name: Terraform Validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Validating Terraform configuration..."
          terraform validate

      - name: Terraform Plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Creating Terraform plan..."
          terraform plan -var-file=${{ env.ENVIRONMENT }}.tfvars -out=tfplan
          
      - name: Terraform Apply
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Applying Terraform configuration..."
          terraform apply -auto-approve tfplan
          echo "‚úÖ Infrastructure created successfully!"

      - name: Get Terraform Outputs
        id: tf-output
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          echo "Reading Terraform outputs..."
          
          # Get outputs from created infrastructure
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_NAME=$(terraform output -raw acr_name)
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw aks_resource_group_name)
          POSTGRES_HOST=$(terraform output -raw postgres_fqdn)
          MANAGED_IDENTITY_CLIENT_ID=$(terraform output -raw workload_identity_client_id)
          
          echo "üì¶ ACR: $ACR_LOGIN_SERVER"
          echo "‚ò∏Ô∏è  AKS: $AKS_CLUSTER_NAME"
          echo "üóÑÔ∏è  PostgreSQL: $POSTGRES_HOST"
          
          # Set as job outputs
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "aks_resource_group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "managed_identity_client_id=$MANAGED_IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT

  # ============================================
  # JOB 2: Build and Push Docker Images
  # ============================================
  build-and-push:
    name: Build and Push Images
    needs: terraform-deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build microservices with Maven
        run: |
          echo "Building microservices..."
          mvn clean package -DskipTests
          echo "‚úÖ Maven build complete!"

      - name: Log in to Azure Container Registry
        run: |
          echo "Logging into ACR: ${{ needs.terraform-deploy.outputs.acr_name }}"
          az acr login --name ${{ needs.terraform-deploy.outputs.acr_name }}
          echo "‚úÖ Logged into ACR!"

      - name: Build and push Docker images
        env:
          ACR_LOGIN_SERVER: ${{ needs.terraform-deploy.outputs.acr_login_server }}
        run: |
          echo "Building Docker images..."
          
          # Customer Service
          echo "Building customer-service..."
          docker build -t $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG ./customer-service
          docker push $ACR_LOGIN_SERVER/customer-service:$IMAGE_TAG
          
          # Document Service
          echo "Building document-service..."
          docker build -t $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG ./document-service
          docker push $ACR_LOGIN_SERVER/document-service:$IMAGE_TAG
          
          # Account Service
          echo "Building account-service..."
          docker build -t $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG ./account-service
          docker push $ACR_LOGIN_SERVER/account-service:$IMAGE_TAG
          
          # Notification Service
          echo "Building notification-service..."
          docker build -t $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG ./notification-service
          docker push $ACR_LOGIN_SERVER/notification-service:$IMAGE_TAG
          
          echo "‚úÖ All images pushed to ACR!"

  # ============================================
  # JOB 3: Deploy to AKS
  # ============================================
  deploy-to-aks:
    name: Deploy to AKS
    needs: [terraform-deploy, build-and-push]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          cluster-name: ${{ needs.terraform-deploy.outputs.aks_cluster_name }}
          resource-group: ${{ needs.terraform-deploy.outputs.aks_resource_group }}

      - name: Replace placeholders in k8s manifests
        env:
          ACR_LOGIN_SERVER: ${{ needs.terraform-deploy.outputs.acr_login_server }}
          POSTGRES_HOST: ${{ needs.terraform-deploy.outputs.postgres_host }}
          MANAGED_IDENTITY_CLIENT_ID: ${{ needs.terraform-deploy.outputs.managed_identity_client_id }}
        run: |
          echo "Updating Kubernetes manifests..."
          
          # Replace ACR and image tags
          sed -i "s|<ACR_LOGIN_SERVER>|$ACR_LOGIN_SERVER|g" k8s/*.yaml
          sed -i "s|<TAG>|$IMAGE_TAG|g" k8s/*.yaml
          
          # Replace managed identity for workload identity
          sed -i "s|<MANAGED_IDENTITY_CLIENT_ID>|$MANAGED_IDENTITY_CLIENT_ID|g" k8s/*.yaml
          
          # Replace postgres host (no passwords - using managed identity!)
          sed -i "s|<POSTGRES_HOST>|$POSTGRES_HOST|g" k8s/*.yaml
          
          echo "‚úÖ Manifests updated!"

      - name: Deploy ConfigMaps and Secrets
        run: |
          echo "Deploying ConfigMaps and Secrets..."
          kubectl apply -f k8s/customer-service-configmap.yaml
          kubectl apply -f k8s/document-service-configmap.yaml
          kubectl apply -f k8s/account-service-configmap.yaml
          kubectl apply -f k8s/notification-service-configmap.yaml
          kubectl apply -f k8s/customer-service-secret.yaml
          kubectl apply -f k8s/document-service-secret.yaml
          kubectl apply -f k8s/account-service-secret.yaml
          kubectl apply -f k8s/notification-service-secret.yaml
          echo "‚úÖ ConfigMaps and Secrets deployed!"

      - name: Deploy Services
        run: |
          echo "Deploying Kubernetes Services..."
          kubectl apply -f k8s/customer-service-service.yaml
          kubectl apply -f k8s/document-service-service.yaml
          kubectl apply -f k8s/account-service-service.yaml
          kubectl apply -f k8s/notification-service-service.yaml
          echo "‚úÖ Services deployed!"

      - name: Deploy Applications
        run: |
          echo "Deploying applications to AKS..."
          kubectl apply -f k8s/customer-service-deployment.yaml
          kubectl apply -f k8s/document-service-deployment.yaml
          kubectl apply -f k8s/account-service-deployment.yaml
          kubectl apply -f k8s/notification-service-deployment.yaml
          echo "‚úÖ Applications deployed!"

      - name: Wait for deployments to be ready
        run: |
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/customer-service --timeout=300s
          kubectl rollout status deployment/document-service --timeout=300s
          kubectl rollout status deployment/account-service --timeout=300s
          kubectl rollout status deployment/notification-service --timeout=300s
          echo "‚úÖ All deployments ready!"

      - name: Get Service Information
        run: |
          echo "=========================================="
          echo "Deployment Summary"
          echo "=========================================="
          echo ""
          echo "üì¶ Pods:"
          kubectl get pods -o wide
          echo ""
          echo "üåê Services:"
          kubectl get services -o wide
          echo ""
          echo "‚úÖ Deployment complete!"
