name: Deploy to AKS

on:
  push:
    branches:
      - main

# OIDC requires id-token: write permission
permissions:
  id-token: write  # Required for OIDC token generation
  contents: read   # Required to checkout code

env:
  IMAGE_TAG: ${{ github.sha }}
  TF_WORKING_DIR: ./infrastructure
  ENVIRONMENT: dev  # or prod

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      acr_login_server: ${{ steps.terraform-outputs.outputs.acr_login_server }}
      aks_cluster_name: ${{ steps.terraform-outputs.outputs.aks_cluster_name }}
      aks_resource_group: ${{ steps.terraform-outputs.outputs.aks_resource_group }}
      postgres_host: ${{ steps.terraform-outputs.outputs.postgres_host }}
      managed_identity_client_id: ${{ steps.terraform-outputs.outputs.managed_identity_client_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # OIDC Authentication (No secrets needed!) ✅
      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          # No client-secret needed! GitHub generates OIDC token automatically

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Get Terraform Outputs
        id: terraform-outputs
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          terraform init
          
          # Get all outputs we need from Terraform state
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          ACR_NAME=$(terraform output -raw acr_name)
          AKS_CLUSTER_NAME=$(terraform output -raw aks_cluster_name)
          AKS_RESOURCE_GROUP=$(terraform output -raw aks_resource_group_name)
          POSTGRES_HOST=$(terraform output -raw postgres_fqdn)
          MANAGED_IDENTITY_CLIENT_ID=$(terraform output -raw workload_identity_client_id)
          
          # Set as outputs for next job
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "aks_cluster_name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "aks_resource_group=$AKS_RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "managed_identity_client_id=$MANAGED_IDENTITY_CLIENT_ID" >> $GITHUB_OUTPUT
          
          # Also set as env vars for this job
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_ENV

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build microservices
        run: |
          mvn clean package -DskipTests

      - name: Log in to Azure Container Registry (using Service Principal)
        run: |
          # ACR login using the service principal that's already logged in
          az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push images
        run: |
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/customer-service:$IMAGE_TAG ./customer-service
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/document-service:$IMAGE_TAG ./document-service
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/account-service:$IMAGE_TAG ./account-service
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/notification-service:$IMAGE_TAG ./notification-service
          docker push ${{ env.ACR_LOGIN_SERVER }}/customer-service:$IMAGE_TAG
          docker push ${{ env.ACR_LOGIN_SERVER }}/document-service:$IMAGE_TAG
          docker push ${{ env.ACR_LOGIN_SERVER }}/account-service:$IMAGE_TAG
          docker push ${{ env.ACR_LOGIN_SERVER }}/notification-service:$IMAGE_TAG

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # OIDC Authentication (No secrets needed!) ✅
      - name: Azure Login with OIDC
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set AKS context
        uses: azure/aks-set-context@v3
        with:
          cluster-name: ${{ needs.build-and-push.outputs.aks_cluster_name }}
          resource-group: ${{ needs.build-and-push.outputs.aks_resource_group }}

      - name: Replace placeholders in k8s files
        run: |
          # Get values from previous job's outputs
          ACR_LOGIN_SERVER="${{ needs.build-and-push.outputs.acr_login_server }}"
          POSTGRES_HOST="${{ needs.build-and-push.outputs.postgres_host }}"
          MANAGED_IDENTITY_CLIENT_ID="${{ needs.build-and-push.outputs.managed_identity_client_id }}"
          
          # Replace ACR and image tags
          sed -i "s|<ACR_LOGIN_SERVER>|$ACR_LOGIN_SERVER|g" k8s/*.yaml
          sed -i "s|<TAG>|$IMAGE_TAG|g" k8s/*.yaml
          
          # Replace managed identity for workload identity
          sed -i "s|<MANAGED_IDENTITY_CLIENT_ID>|$MANAGED_IDENTITY_CLIENT_ID|g" k8s/*.yaml
          
          # Replace postgres host (no passwords needed - using managed identity!)
          sed -i "s|<POSTGRES_HOST>|$POSTGRES_HOST|g" k8s/*.yaml
          
          # Note: NO PostgreSQL passwords! Applications use Azure AD authentication via Managed Identity

      - name: Deploy ConfigMaps and Secrets
        run: |
          kubectl apply -f k8s/customer-service-configmap.yaml
          kubectl apply -f k8s/document-service-configmap.yaml
          kubectl apply -f k8s/account-service-configmap.yaml
          kubectl apply -f k8s/notification-service-configmap.yaml
          kubectl apply -f k8s/customer-service-secret.yaml
          kubectl apply -f k8s/document-service-secret.yaml
          kubectl apply -f k8s/account-service-secret.yaml
          kubectl apply -f k8s/notification-service-secret.yaml

      - name: Deploy Services
        run: |
          kubectl apply -f k8s/customer-service-service.yaml
          kubectl apply -f k8s/document-service-service.yaml
          kubectl apply -f k8s/account-service-service.yaml
          kubectl apply -f k8s/notification-service-service.yaml

      - name: Deploy to AKS
        run: |
          kubectl apply -f k8s/customer-service-deployment.yaml
          kubectl apply -f k8s/document-service-deployment.yaml
          kubectl apply -f k8s/account-service-deployment.yaml
          kubectl apply -f k8s/notification-service-deployment.yaml

      - name: Wait for deployments
        run: |
          kubectl rollout status deployment/customer-service --timeout=300s
          kubectl rollout status deployment/document-service --timeout=300s
          kubectl rollout status deployment/account-service --timeout=300s
          kubectl rollout status deployment/notification-service --timeout=300s

      - name: Get Service IPs
        run: |
          echo "=== Service External IPs ==="
          kubectl get services -o wide
