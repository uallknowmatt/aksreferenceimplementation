# Azure Deployment Prerequisites

## ğŸ¯ REVOLUTIONARY APPROACH: Only 1 Secret Needed!

**Before:** 9 GitHub secrets to manage  
**After:** **ONLY 1 SECRET!** ğŸ‰

All infrastructure values (ACR, AKS, PostgreSQL) are fetched **dynamically** from Terraform at runtime. No hardcoded secrets!

---

## âš ï¸ IMPORTANT: Correct Order of Operations

**To avoid deployment failures, follow this exact order:**

1. âœ… **Disable GitHub Actions temporarily** (prevent premature deployment)
2. âœ… **Run Terraform** to create ALL infrastructure (including service principal!)
3. âœ… **Configure 1 GitHub Secret** (AZURE_CREDENTIALS only!)
4. âœ… **Re-enable GitHub Actions**
5. âœ… **Push code** to trigger deployment

**Why this order?** If you push code before Terraform creates infrastructure, the workflow will fail. If you don't disable Actions first, it will trigger before setup is complete.

---

## âœ… What's Automated

### Infrastructure (100% Terraform)
1. **Liquibase Implementation** - âœ… Production-grade database migrations
2. **Dev Profiles** - âœ… All services configured for Azure PostgreSQL with Managed Identity
3. **Kubernetes Manifests** - âœ… ConfigMaps, Services, Deployments ready
4. **Terraform Configuration** - âœ… Infrastructure as Code validated
5. **GitHub Actions Workflow** - âœ… CI/CD pipeline with dynamic value fetching
6. **Service Principal** - âœ… Auto-created by Terraform (no manual commands!)
7. **Workload Identity** - âœ… Passwordless PostgreSQL authentication
8. **Role Assignments** - âœ… All permissions configured automatically

### What You NO LONGER Need to Configure

âŒ ~~ACR_LOGIN_SERVER~~ â†’ Fetched from Terraform  
âŒ ~~ACR_USERNAME~~ â†’ Service principal authentication  
âŒ ~~ACR_PASSWORD~~ â†’ Service principal authentication  
âŒ ~~AKS_CLUSTER_NAME~~ â†’ Fetched from Terraform  
âŒ ~~AKS_RESOURCE_GROUP~~ â†’ Fetched from Terraform  
âŒ ~~POSTGRES_HOST~~ â†’ Fetched from Terraform  
âŒ ~~POSTGRES_USERNAME~~ â†’ Passwordless via Managed Identity!  
âŒ ~~POSTGRES_PASSWORD~~ â†’ Passwordless via Managed Identity!  
âŒ ~~MANAGED_IDENTITY_CLIENT_ID~~ â†’ Fetched from Terraform  

### What You DO Need

âœ… **AZURE_CREDENTIALS** (only 1 secret!) â†’ Auto-generated by Terraform

---

## ğŸ¯ Why This Approach is Better

### ğŸ” Security
- **Fewer secrets** = smaller attack surface (89% reduction!)
- **No password rotation** for databases (Azure AD authentication)
- **No hardcoded values** (everything dynamic from Terraform)
- **Single source of truth** (Terraform state, not GitHub secrets)

### ğŸš€ Operations
- **Simpler setup** (1 secret vs 9)
- **No drift** between secrets and infrastructure
- **Environment agnostic** (same secret works for dev/staging/prod)
- **Easier troubleshooting** (values visible in workflow logs)

### ğŸ”„ Maintenance
- **Automated updates** (infrastructure changes propagate automatically)
- **Less documentation** to maintain
- **Fewer opportunities for errors**
- **Team-friendly** (anyone with Terraform access can deploy)

---

## ğŸ“‹ Choose Your Authentication Method

### ğŸ¯ Two Options Available

**OPTION 1: GitHub OIDC (RECOMMENDED)** âœ…
- **Zero secrets** stored in GitHub!
- **Zero rotation** needed
- **Maximum security** (tokens expire in minutes)
- **Microsoft recommended**

**OPTION 2: Service Principal Secret (Legacy)** âš ï¸
- 1 long-lived secret (clientSecret)
- Annual rotation required
- More maintenance overhead
- Not recommended by Microsoft

### ğŸ“Š Quick Comparison

| Aspect | OIDC âœ… | Service Principal âš ï¸ |
|--------|---------|---------------------|
| Secrets stored | 0 (just 3 IDs) | 1 (clientSecret) |
| Token lifetime | Minutes | 1 year |
| Rotation needed | NO | YES (automated) |
| Security risk | Very low | Medium |
| Maintenance | Zero | Rotation workflow |

**See AUTHENTICATION_COMPARISON.md for complete details.**

---

## ğŸ” OPTION 1: GitHub OIDC (Recommended)

### What You Need (3 Non-Secret IDs)

Instead of storing a secret, you store 3 **IDs** (not actually secrets!):

1. **AZURE_CLIENT_ID** - Just an identifier (safe to share)
2. **AZURE_TENANT_ID** - Just an identifier (safe to share)
3. **AZURE_SUBSCRIPTION_ID** - Just an identifier (safe to share)

### How It Works

```
1. Workflow starts
   â†“
2. GitHub generates OIDC token (expires in minutes!)
   â†“
3. Azure validates token and issues access token
   â†“
4. Workflow uses access token
   â†“
5. Token expires after run (automatic cleanup!)
```

**No long-lived secrets anywhere!** GitHub generates a NEW token for every workflow run.

### Security Benefits

âœ… **Leaked "secrets" = No impact** (they're just IDs, not credentials)  
âœ… **No rotation needed** (tokens auto-expire)  
âœ… **Can't replay tokens** (single-use)  
âœ… **Complete audit trail** (every token logged)  
âœ… **Repository-specific** (can't use from elsewhere)  

### Setup Guide

ğŸ‘‰ **See OIDC_SETUP_GUIDE.md for complete OIDC setup instructions**

**Quick version:**
1. Run Terraform locally (creates federated credential)
2. Get 3 IDs from `terraform output github_secrets_oidc_summary`
3. Add to GitHub secrets
4. Done! Zero maintenance forever.

---

## ğŸ”§ OPTION 2: Service Principal Secret (Legacy)

### What You Need (1 Secret)

**AZURE_CREDENTIALS** (Service Principal JSON)

This secret contains everything needed for GitHub Actions to authenticate to Azure:

```json
{
  "clientId": "<service-principal-app-id>",
  "clientSecret": "<service-principal-password>",  â† ACTUAL SECRET!
  "subscriptionId": "<azure-subscription-id>",
  "tenantId": "<azure-tenant-id>"
}
```

**This is AUTO-GENERATED by Terraform!** No manual `az ad sp create-for-rbac` commands needed.

**What it enables:**
- âœ… Login to Azure
- âœ… Read Terraform state
- âœ… Push Docker images to ACR
- âœ… Deploy to AKS
- âœ… Manage all Azure resources

**All other values** (ACR name, AKS name, PostgreSQL host, etc.) are fetched dynamically from Terraform outputs during the workflow run.

### ğŸ”„ Automatic Rotation

**This secret CAN rotate itself automatically:** ğŸ‰

- âœ… **Daily checks** at 2 AM UTC
- âœ… **Auto-rotates** 10 days before expiration
- âœ… **Zero downtime** (overlapping validity)
- âœ… **No human interaction** needed!

See **AUTOMATED_CREDENTIAL_ROTATION.md** for details.

### Setup Guide

ğŸ‘‰ **See BOOTSTRAP_GUIDE.md for complete service principal setup**

---

## ğŸ¯ First Time Setup vs Regular Deployment

### First Time Ever? (Bootstrap Required)

Regardless of which authentication method you choose, you need a **one-time bootstrap**:

If this is your **very first deployment** and you don't have `AZURE_CREDENTIALS` yet, you need to do a **one-time bootstrap**:

ğŸ‘‰ **Follow: BOOTSTRAP_GUIDE.md** (comprehensive step-by-step)

**OR use the automated script:**

```powershell
cd c:\genaiexperiments\accountopening
.\bootstrap.ps1
```

This script will:
1. âœ… Check prerequisites (Azure CLI, Terraform)
2. âœ… Create infrastructure with Terraform
3. âœ… Generate the `AZURE_CREDENTIALS` JSON
4. âœ… Show you exactly what to paste into GitHub

**After bootstrap, come back here for regular deployments!**

---

### Already Have AZURE_CREDENTIALS? (Regular Deployment)

Follow the steps below â¬‡ï¸

---

## ğŸ“‹ Setup Instructions (3 Simple Steps!)

### Step 1: Disable GitHub Actions Temporarily

**Why:** Prevent automatic deployment while setting up infrastructure

1. Go to your GitHub repository
2. Navigate to **Settings** â†’ **Actions** â†’ **General**
3. Under "Actions permissions", select **Disable actions**
4. Click **Save**

---

### Step 2: Run Terraform (Creates EVERYTHING!)

```bash
cd infrastructure

# Login to Azure
az login

# Initialize Terraform
terraform init

# Create dev environment (takes 10-15 minutes)
terraform apply -var-file=dev.tfvars
```

**What Terraform creates:**
- âœ… Resource Group
- âœ… AKS Cluster (with Workload Identity enabled)
- âœ… Azure Container Registry
- âœ… PostgreSQL Flexible Server (with Azure AD authentication)
- âœ… 4 PostgreSQL databases (customerdb, documentdb, accountdb, notificationdb)
- âœ… VNet and Subnets
- âœ… **Service Principal for GitHub Actions** (automated!)
- âœ… **Managed Identity for application pods** (passwordless DB!)
- âœ… All role assignments (Contributor, AcrPush, AKS Admin, PostgreSQL access)
- âœ… Federated identity credentials for Workload Identity
- âœ… Log Analytics workspace
- âœ… Network Security Groups

**Total:** ~15 Azure resources, all configured and ready to use!

---

### Step 3: Get the ONE Secret & Configure GitHub

#### A. Get the Service Principal JSON

After Terraform completes, run:

```bash
cd infrastructure

# See the beautiful summary
terraform output github_secrets_summary

# Get the service principal JSON
terraform output -raw azure_credentials_json
```

**Output example:**
```json
{"clientId":"abc-123-xyz","clientSecret":"super-secret","subscriptionId":"sub-id","tenantId":"tenant-id"}
```

**Copy this entire JSON!**

#### B. Add to GitHub Secrets

1. Go to https://github.com/uallknowmatt/aksreferenceimplementation/settings/secrets/actions
2. Click **New repository secret**
3. Name: `AZURE_CREDENTIALS`
4. Value: Paste the entire JSON from above
5. Click **Add secret**

**That's it! Only 1 secret! ğŸ‰**

#### C. Verify Terraform Outputs (Optional)

Want to see what values the workflow will fetch? Run:

```bash
terraform output acr_login_server
terraform output aks_cluster_name  
terraform output aks_resource_group_name
terraform output postgres_fqdn
terraform output workload_identity_client_id
```

These values are NOT stored as secrets - they're fetched dynamically during deployment!

---

### Step 4: Re-enable GitHub Actions

1. Go back to **Settings** â†’ **Actions** â†’ **General**
2. Under "Actions permissions", select **Allow all actions and reusable workflows**
3. Click **Save**

---

### Step 5: Deploy!

Push code to trigger deployment:

```bash
git push origin main

# Or create empty commit to trigger:
git commit --allow-empty -m "Deploy with minimal secrets approach"
git push origin main
```

---

## ğŸš€ How the Deployment Works

### Workflow Execution Flow

```
1. GitHub Actions triggered by push
   â†“
2. Login to Azure with AZURE_CREDENTIALS
   â†“
3. Run terraform init in infrastructure/
   â†“
4. Fetch dynamic values:
   - ACR login server
   - ACR name  
   - AKS cluster name
   - AKS resource group
   - PostgreSQL host
   - Workload identity client ID
   â†“
5. Build all 4 microservices with Maven
   â†“
6. Login to ACR using service principal (already logged in!)
   â†“
7. Build and push 4 Docker images
   â†“
8. Set AKS context
   â†“
9. Replace placeholders in k8s manifests with dynamic values
   â†“
10. Deploy ConfigMaps and Services
   â†“
11. Deploy Deployments (with Workload Identity annotations)
   â†“
12. Wait for rollout completion
   â†“
13. Get service IPs
   â†“
14. âœ… Deployment complete!
```

### What Happens in AKS Pods

```
1. Pod starts with Workload Identity annotation
   â†“
2. Pod gets Azure AD token from Workload Identity
   â†“
3. Liquibase runs database migrations
   â†“
4. Spring Boot starts
   â†“
5. Application connects to PostgreSQL using Azure AD token
   (NO PASSWORD NEEDED!)
   â†“
6. Service is ready to handle requests
```

---

## ğŸ” Monitoring Deployment

### 1. Watch GitHub Actions

- Go to https://github.com/uallknowmatt/aksreferenceimplementation/actions
- Click on the latest workflow run
- Watch "build-and-push" job (Maven build, Docker push)
- Watch "deploy" job (Kubernetes deployment)

### 2. Monitor AKS Pods

```bash
# Get AKS credentials
az aks get-credentials \
  --resource-group $(cd infrastructure && terraform output -raw aks_resource_group_name) \
  --name $(cd infrastructure && terraform output -raw aks_cluster_name)

# Watch pods come online
kubectl get pods -w

# Check pod details
kubectl describe pod <pod-name>

# View logs (Liquibase migrations + app startup)
kubectl logs -f deployment/customer-service
kubectl logs -f deployment/document-service  
kubectl logs -f deployment/account-service
kubectl logs -f deployment/notification-service
```

### 3. Verify Liquibase Migrations

```bash
# Check Liquibase ran successfully
kubectl logs deployment/customer-service | grep -i liquibase

# Should see:
# "Running Changeset: db/changelog/changes/001-create-customer-table.yaml"
# "ChangeSet...ran successfully"
```

### 4. Check Service Connectivity

```bash
# Get service external IPs (if using LoadBalancer)
kubectl get services

# Test health endpoints
kubectl port-forward svc/customer-service 8081:8081
curl http://localhost:8081/actuator/health
```

---

## âš™ï¸ Current Status

**Code Status**: âœ… Ready to deploy  
**Liquibase**: âœ… Fully implemented and tested  
**Terraform**: âœ… Fully automated (service principal, workload identity, all resources)  
**Workflow**: âœ… Dynamic value fetching configured  
**GitHub Secrets**: â³ Only need AZURE_CREDENTIALS (1 secret!)  
**Infrastructure**: â³ Awaiting `terraform apply`  
**Deployment**: â³ Ready once Terraform completes  

---

## ğŸ”§ Troubleshooting

### Workflow fails with "terraform output" errors

**Problem:** Can't read Terraform state

**Solutions:**
1. Verify Terraform was run: `cd infrastructure && terraform state list`
2. Check service principal has permissions to read resource group
3. Ensure Terraform backend is accessible (if using remote state)

```bash
# Debug: Check Terraform state
cd infrastructure
terraform init
terraform state list
terraform output  # Should show all outputs
```

### ACR login fails in workflow

**Problem:** `az acr login --name <ACR>` fails

**Solutions:**
1. Verify service principal has AcrPush role:
   ```bash
   cd infrastructure
   terraform state show azurerm_role_assignment.github_actions_acr_push
   ```
2. Check ACR exists:
   ```bash
   az acr show --name $(terraform output -raw acr_name)
   ```

### Pods can't connect to PostgreSQL

**Problem:** Database connection errors in pod logs

**Solutions:**
1. Check Workload Identity is configured:
   ```bash
   kubectl describe serviceaccount customer-service
   # Should have: azure.workload.identity/client-id annotation
   
   kubectl describe pod <pod-name>
   # Should have: azure.workload.identity/use=true label
   ```

2. Verify managed identity has PostgreSQL access:
   ```bash
   cd infrastructure
   terraform state show azurerm_role_assignment.workload_identity_postgres
   ```

3. Check PostgreSQL firewall allows AKS subnet:
   ```bash
   az postgres flexible-server firewall-rule list \
     --resource-group $(terraform output -raw aks_resource_group_name) \
     --name $(terraform output -raw postgres_fqdn | cut -d'.' -f1)
   ```

### Liquibase migration fails

**Problem:** "Schema-validation" or migration errors in pod logs

**Solutions:**
1. Check database exists:
   ```bash
   # Get pod shell
   kubectl exec -it <pod-name> -- /bin/sh
   
   # Inside pod, check connection (using Azure AD!)
   nc -zv $POSTGRES_HOST 5432
   ```

2. View Liquibase logs:
   ```bash
   kubectl logs <pod-name> | grep -i liquibase
   ```

3. Verify changelogs are correct (already tested locally!)

### GitHub Actions disabled and forgot to re-enable

**Problem:** Pushed code but workflow doesn't run

**Solution:**
1. Go to repo â†’ Settings â†’ Actions â†’ General
2. Select "Allow all actions and reusable workflows"
3. Save
4. Push again or trigger manually

---

## ğŸ“Š Comparison: Before vs After

| Aspect | Old Approach | New Approach |
|--------|-------------|--------------|
| **GitHub Secrets** | 9 secrets | **1 secret** ğŸ‰ |
| **Manual steps** | Many (SP creation, ACR creds, etc.) | Minimal (terraform apply) |
| **PostgreSQL auth** | Username + password | **Passwordless** via Managed Identity |
| **Secret rotation** | Regular (every 90 days) | Once/year (service principal only) |
| **Infrastructure changes** | Update 9 secrets manually | **Automatic** via Terraform |
| **Setup complexity** | High | **Low** |
| **Security** | Passwords in GitHub | **No passwords** where possible |
| **Debugging** | Hard (secrets hidden) | **Easy** (values in logs) |
| **Team collaboration** | Complex handoff | **Simple** (just share Terraform access) |
| **Environment setup** | Different secrets per env | **Same secret**, different Terraform workspace |

---

## âœ… Checklist

Use this for your deployment:

- [ ] Liquibase implemented âœ… (already done!)
- [ ] GitHub Actions disabled temporarily
- [ ] `terraform apply` completed successfully
- [ ] Service principal JSON obtained (`terraform output -raw azure_credentials_json`)
- [ ] AZURE_CREDENTIALS secret added to GitHub (only 1 secret!)
- [ ] GitHub Actions re-enabled
- [ ] Code pushed to trigger deployment
- [ ] Workflow "build-and-push" job succeeded
- [ ] Workflow "deploy" job succeeded
- [ ] All 4 pods running in AKS
- [ ] Liquibase migrations executed successfully
- [ ] Services responding to health checks
- [ ] No PostgreSQL password errors (using Managed Identity!)

---

## ğŸ‰ Summary

### What Makes This Deployment Special

**1. Minimal Secrets (89% Reduction!)**
- From 9 secrets â†’ 1 secret
- Only AZURE_CREDENTIALS needed
- Everything else fetched dynamically

**2. Passwordless Database Authentication**
- No PostgreSQL passwords anywhere
- Azure AD authentication via Workload Identity
- More secure, less to manage

**3. Infrastructure as Code**
- Service principal created by Terraform
- Managed identity created by Terraform
- All permissions configured automatically
- No manual Azure portal clicks

**4. Dynamic Configuration**
- ACR name fetched at runtime
- AKS name fetched at runtime
- PostgreSQL host fetched at runtime
- No hardcoded values in workflow

**5. Production-Ready**
- Liquibase for database migrations
- Workload Identity for pod authentication
- Proper role assignments
- Audit trail via Terraform

### What You've Achieved

âœ… **Full automation** - Infrastructure and deployment fully automated  
âœ… **Best practices** - Following Azure and Kubernetes security guidelines  
âœ… **Team-friendly** - Simple setup, easy to replicate  
âœ… **Maintainable** - Single source of truth (Terraform)  
âœ… **Secure** - Minimal secrets, passwordless where possible  

---

## ğŸ“– Next Steps

Your deployment is **fully configured and ready**! Just:

1. **Disable GitHub Actions** (via web UI)
2. **Run** `terraform apply -var-file=dev.tfvars`
3. **Get** `terraform output -raw azure_credentials_json`
4. **Add** as AZURE_CREDENTIALS secret in GitHub
5. **Re-enable** GitHub Actions
6. **Push** code
7. **Watch** the magic happen! ğŸš€

---

## ğŸ“š Additional Documentation

- **AUTOMATED_CREDENTIAL_ROTATION.md** - ğŸ”„ Zero-downtime automatic secret rotation
- **MINIMAL_SECRETS_DEPLOYMENT.md** - Detailed explanation of minimal secrets approach
- **AUTOMATED_SERVICE_PRINCIPAL.md** - Service principal automation details
- **LIQUIBASE_COMPLETE.md** - Liquibase implementation summary
- **DOCKER_LOCAL_SETUP.md** - Local development with Docker PostgreSQL

---

**Your deployment is now enterprise-grade: automated, secure, and maintainable! ğŸ‰**
