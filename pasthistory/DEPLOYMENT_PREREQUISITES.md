# Azure Deployment Prerequisites

## 🎯 REVOLUTIONARY APPROACH: Only 1 Secret Needed!

**Before:** 9 GitHub secrets to manage  
**After:** **ONLY 1 SECRET!** 🎉

All infrastructure values (ACR, AKS, PostgreSQL) are fetched **dynamically** from Terraform at runtime. No hardcoded secrets!

---

## ⚠️ IMPORTANT: Correct Order of Operations

**To avoid deployment failures, follow this exact order:**

1. ✅ **Disable GitHub Actions temporarily** (prevent premature deployment)
2. ✅ **Run Terraform** to create ALL infrastructure (including service principal!)
3. ✅ **Configure 1 GitHub Secret** (AZURE_CREDENTIALS only!)
4. ✅ **Re-enable GitHub Actions**
5. ✅ **Push code** to trigger deployment

**Why this order?** If you push code before Terraform creates infrastructure, the workflow will fail. If you don't disable Actions first, it will trigger before setup is complete.

---

## ✅ What's Automated

### Infrastructure (100% Terraform)
1. **Liquibase Implementation** - ✅ Production-grade database migrations
2. **Dev Profiles** - ✅ All services configured for Azure PostgreSQL with Managed Identity
3. **Kubernetes Manifests** - ✅ ConfigMaps, Services, Deployments ready
4. **Terraform Configuration** - ✅ Infrastructure as Code validated
5. **GitHub Actions Workflow** - ✅ CI/CD pipeline with dynamic value fetching
6. **Service Principal** - ✅ Auto-created by Terraform (no manual commands!)
7. **Workload Identity** - ✅ Passwordless PostgreSQL authentication
8. **Role Assignments** - ✅ All permissions configured automatically

### What You NO LONGER Need to Configure

❌ ~~ACR_LOGIN_SERVER~~ → Fetched from Terraform  
❌ ~~ACR_USERNAME~~ → Service principal authentication  
❌ ~~ACR_PASSWORD~~ → Service principal authentication  
❌ ~~AKS_CLUSTER_NAME~~ → Fetched from Terraform  
❌ ~~AKS_RESOURCE_GROUP~~ → Fetched from Terraform  
❌ ~~POSTGRES_HOST~~ → Fetched from Terraform  
❌ ~~POSTGRES_USERNAME~~ → Passwordless via Managed Identity!  
❌ ~~POSTGRES_PASSWORD~~ → Passwordless via Managed Identity!  
❌ ~~MANAGED_IDENTITY_CLIENT_ID~~ → Fetched from Terraform  

### What You DO Need

✅ **AZURE_CREDENTIALS** (only 1 secret!) → Auto-generated by Terraform

---

## 🎯 Why This Approach is Better

### 🔐 Security
- **Fewer secrets** = smaller attack surface (89% reduction!)
- **No password rotation** for databases (Azure AD authentication)
- **No hardcoded values** (everything dynamic from Terraform)
- **Single source of truth** (Terraform state, not GitHub secrets)

### 🚀 Operations
- **Simpler setup** (1 secret vs 9)
- **No drift** between secrets and infrastructure
- **Environment agnostic** (same secret works for dev/staging/prod)
- **Easier troubleshooting** (values visible in workflow logs)

### 🔄 Maintenance
- **Automated updates** (infrastructure changes propagate automatically)
- **Less documentation** to maintain
- **Fewer opportunities for errors**
- **Team-friendly** (anyone with Terraform access can deploy)

---

## 📋 Choose Your Authentication Method

### 🎯 Two Options Available

**OPTION 1: GitHub OIDC (RECOMMENDED)** ✅
- **Zero secrets** stored in GitHub!
- **Zero rotation** needed
- **Maximum security** (tokens expire in minutes)
- **Microsoft recommended**

**OPTION 2: Service Principal Secret (Legacy)** ⚠️
- 1 long-lived secret (clientSecret)
- Annual rotation required
- More maintenance overhead
- Not recommended by Microsoft

### 📊 Quick Comparison

| Aspect | OIDC ✅ | Service Principal ⚠️ |
|--------|---------|---------------------|
| Secrets stored | 0 (just 3 IDs) | 1 (clientSecret) |
| Token lifetime | Minutes | 1 year |
| Rotation needed | NO | YES (automated) |
| Security risk | Very low | Medium |
| Maintenance | Zero | Rotation workflow |

**See AUTHENTICATION_COMPARISON.md for complete details.**

---

## 🔐 OPTION 1: GitHub OIDC (Recommended)

### What You Need (3 Non-Secret IDs)

Instead of storing a secret, you store 3 **IDs** (not actually secrets!):

1. **AZURE_CLIENT_ID** - Just an identifier (safe to share)
2. **AZURE_TENANT_ID** - Just an identifier (safe to share)
3. **AZURE_SUBSCRIPTION_ID** - Just an identifier (safe to share)

### How It Works

```
1. Workflow starts
   ↓
2. GitHub generates OIDC token (expires in minutes!)
   ↓
3. Azure validates token and issues access token
   ↓
4. Workflow uses access token
   ↓
5. Token expires after run (automatic cleanup!)
```

**No long-lived secrets anywhere!** GitHub generates a NEW token for every workflow run.

### Security Benefits

✅ **Leaked "secrets" = No impact** (they're just IDs, not credentials)  
✅ **No rotation needed** (tokens auto-expire)  
✅ **Can't replay tokens** (single-use)  
✅ **Complete audit trail** (every token logged)  
✅ **Repository-specific** (can't use from elsewhere)  

### Setup Guide

👉 **See OIDC_SETUP_GUIDE.md for complete OIDC setup instructions**

**Quick version:**
1. Run Terraform locally (creates federated credential)
2. Get 3 IDs from `terraform output github_secrets_oidc_summary`
3. Add to GitHub secrets
4. Done! Zero maintenance forever.

---

## 🔧 OPTION 2: Service Principal Secret (Legacy)

### What You Need (1 Secret)

**AZURE_CREDENTIALS** (Service Principal JSON)

This secret contains everything needed for GitHub Actions to authenticate to Azure:

```json
{
  "clientId": "<service-principal-app-id>",
  "clientSecret": "<service-principal-password>",  ← ACTUAL SECRET!
  "subscriptionId": "<azure-subscription-id>",
  "tenantId": "<azure-tenant-id>"
}
```

**This is AUTO-GENERATED by Terraform!** No manual `az ad sp create-for-rbac` commands needed.

**What it enables:**
- ✅ Login to Azure
- ✅ Read Terraform state
- ✅ Push Docker images to ACR
- ✅ Deploy to AKS
- ✅ Manage all Azure resources

**All other values** (ACR name, AKS name, PostgreSQL host, etc.) are fetched dynamically from Terraform outputs during the workflow run.

### 🔄 Automatic Rotation

**This secret CAN rotate itself automatically:** 🎉

- ✅ **Daily checks** at 2 AM UTC
- ✅ **Auto-rotates** 10 days before expiration
- ✅ **Zero downtime** (overlapping validity)
- ✅ **No human interaction** needed!

See **AUTOMATED_CREDENTIAL_ROTATION.md** for details.

### Setup Guide

👉 **See BOOTSTRAP_GUIDE.md for complete service principal setup**

---

## 🎯 First Time Setup vs Regular Deployment

### First Time Ever? (Bootstrap Required)

Regardless of which authentication method you choose, you need a **one-time bootstrap**:

If this is your **very first deployment** and you don't have `AZURE_CREDENTIALS` yet, you need to do a **one-time bootstrap**:

👉 **Follow: BOOTSTRAP_GUIDE.md** (comprehensive step-by-step)

**OR use the automated script:**

```powershell
cd c:\genaiexperiments\accountopening
.\bootstrap.ps1
```

This script will:
1. ✅ Check prerequisites (Azure CLI, Terraform)
2. ✅ Create infrastructure with Terraform
3. ✅ Generate the `AZURE_CREDENTIALS` JSON
4. ✅ Show you exactly what to paste into GitHub

**After bootstrap, come back here for regular deployments!**

---

### Already Have AZURE_CREDENTIALS? (Regular Deployment)

Follow the steps below ⬇️

---

## 📋 Setup Instructions (3 Simple Steps!)

### Step 1: Disable GitHub Actions Temporarily

**Why:** Prevent automatic deployment while setting up infrastructure

1. Go to your GitHub repository
2. Navigate to **Settings** → **Actions** → **General**
3. Under "Actions permissions", select **Disable actions**
4. Click **Save**

---

### Step 2: Run Terraform (Creates EVERYTHING!)

```bash
cd infrastructure

# Login to Azure
az login

# Initialize Terraform
terraform init

# Create dev environment (takes 10-15 minutes)
terraform apply -var-file=dev.tfvars
```

**What Terraform creates:**
- ✅ Resource Group
- ✅ AKS Cluster (with Workload Identity enabled)
- ✅ Azure Container Registry
- ✅ PostgreSQL Flexible Server (with Azure AD authentication)
- ✅ 4 PostgreSQL databases (customerdb, documentdb, accountdb, notificationdb)
- ✅ VNet and Subnets
- ✅ **Service Principal for GitHub Actions** (automated!)
- ✅ **Managed Identity for application pods** (passwordless DB!)
- ✅ All role assignments (Contributor, AcrPush, AKS Admin, PostgreSQL access)
- ✅ Federated identity credentials for Workload Identity
- ✅ Log Analytics workspace
- ✅ Network Security Groups

**Total:** ~15 Azure resources, all configured and ready to use!

---

### Step 3: Get the ONE Secret & Configure GitHub

#### A. Get the Service Principal JSON

After Terraform completes, run:

```bash
cd infrastructure

# See the beautiful summary
terraform output github_secrets_summary

# Get the service principal JSON
terraform output -raw azure_credentials_json
```

**Output example:**
```json
{"clientId":"abc-123-xyz","clientSecret":"super-secret","subscriptionId":"sub-id","tenantId":"tenant-id"}
```

**Copy this entire JSON!**

#### B. Add to GitHub Secrets

1. Go to https://github.com/uallknowmatt/aksreferenceimplementation/settings/secrets/actions
2. Click **New repository secret**
3. Name: `AZURE_CREDENTIALS`
4. Value: Paste the entire JSON from above
5. Click **Add secret**

**That's it! Only 1 secret! 🎉**

#### C. Verify Terraform Outputs (Optional)

Want to see what values the workflow will fetch? Run:

```bash
terraform output acr_login_server
terraform output aks_cluster_name  
terraform output aks_resource_group_name
terraform output postgres_fqdn
terraform output workload_identity_client_id
```

These values are NOT stored as secrets - they're fetched dynamically during deployment!

---

### Step 4: Re-enable GitHub Actions

1. Go back to **Settings** → **Actions** → **General**
2. Under "Actions permissions", select **Allow all actions and reusable workflows**
3. Click **Save**

---

### Step 5: Deploy!

Push code to trigger deployment:

```bash
git push origin main

# Or create empty commit to trigger:
git commit --allow-empty -m "Deploy with minimal secrets approach"
git push origin main
```

---

## 🚀 How the Deployment Works

### Workflow Execution Flow

```
1. GitHub Actions triggered by push
   ↓
2. Login to Azure with AZURE_CREDENTIALS
   ↓
3. Run terraform init in infrastructure/
   ↓
4. Fetch dynamic values:
   - ACR login server
   - ACR name  
   - AKS cluster name
   - AKS resource group
   - PostgreSQL host
   - Workload identity client ID
   ↓
5. Build all 4 microservices with Maven
   ↓
6. Login to ACR using service principal (already logged in!)
   ↓
7. Build and push 4 Docker images
   ↓
8. Set AKS context
   ↓
9. Replace placeholders in k8s manifests with dynamic values
   ↓
10. Deploy ConfigMaps and Services
   ↓
11. Deploy Deployments (with Workload Identity annotations)
   ↓
12. Wait for rollout completion
   ↓
13. Get service IPs
   ↓
14. ✅ Deployment complete!
```

### What Happens in AKS Pods

```
1. Pod starts with Workload Identity annotation
   ↓
2. Pod gets Azure AD token from Workload Identity
   ↓
3. Liquibase runs database migrations
   ↓
4. Spring Boot starts
   ↓
5. Application connects to PostgreSQL using Azure AD token
   (NO PASSWORD NEEDED!)
   ↓
6. Service is ready to handle requests
```

---

## 🔍 Monitoring Deployment

### 1. Watch GitHub Actions

- Go to https://github.com/uallknowmatt/aksreferenceimplementation/actions
- Click on the latest workflow run
- Watch "build-and-push" job (Maven build, Docker push)
- Watch "deploy" job (Kubernetes deployment)

### 2. Monitor AKS Pods

```bash
# Get AKS credentials
az aks get-credentials \
  --resource-group $(cd infrastructure && terraform output -raw aks_resource_group_name) \
  --name $(cd infrastructure && terraform output -raw aks_cluster_name)

# Watch pods come online
kubectl get pods -w

# Check pod details
kubectl describe pod <pod-name>

# View logs (Liquibase migrations + app startup)
kubectl logs -f deployment/customer-service
kubectl logs -f deployment/document-service  
kubectl logs -f deployment/account-service
kubectl logs -f deployment/notification-service
```

### 3. Verify Liquibase Migrations

```bash
# Check Liquibase ran successfully
kubectl logs deployment/customer-service | grep -i liquibase

# Should see:
# "Running Changeset: db/changelog/changes/001-create-customer-table.yaml"
# "ChangeSet...ran successfully"
```

### 4. Check Service Connectivity

```bash
# Get service external IPs (if using LoadBalancer)
kubectl get services

# Test health endpoints
kubectl port-forward svc/customer-service 8081:8081
curl http://localhost:8081/actuator/health
```

---

## ⚙️ Current Status

**Code Status**: ✅ Ready to deploy  
**Liquibase**: ✅ Fully implemented and tested  
**Terraform**: ✅ Fully automated (service principal, workload identity, all resources)  
**Workflow**: ✅ Dynamic value fetching configured  
**GitHub Secrets**: ⏳ Only need AZURE_CREDENTIALS (1 secret!)  
**Infrastructure**: ⏳ Awaiting `terraform apply`  
**Deployment**: ⏳ Ready once Terraform completes  

---

## 🔧 Troubleshooting

### Workflow fails with "terraform output" errors

**Problem:** Can't read Terraform state

**Solutions:**
1. Verify Terraform was run: `cd infrastructure && terraform state list`
2. Check service principal has permissions to read resource group
3. Ensure Terraform backend is accessible (if using remote state)

```bash
# Debug: Check Terraform state
cd infrastructure
terraform init
terraform state list
terraform output  # Should show all outputs
```

### ACR login fails in workflow

**Problem:** `az acr login --name <ACR>` fails

**Solutions:**
1. Verify service principal has AcrPush role:
   ```bash
   cd infrastructure
   terraform state show azurerm_role_assignment.github_actions_acr_push
   ```
2. Check ACR exists:
   ```bash
   az acr show --name $(terraform output -raw acr_name)
   ```

### Pods can't connect to PostgreSQL

**Problem:** Database connection errors in pod logs

**Solutions:**
1. Check Workload Identity is configured:
   ```bash
   kubectl describe serviceaccount customer-service
   # Should have: azure.workload.identity/client-id annotation
   
   kubectl describe pod <pod-name>
   # Should have: azure.workload.identity/use=true label
   ```

2. Verify managed identity has PostgreSQL access:
   ```bash
   cd infrastructure
   terraform state show azurerm_role_assignment.workload_identity_postgres
   ```

3. Check PostgreSQL firewall allows AKS subnet:
   ```bash
   az postgres flexible-server firewall-rule list \
     --resource-group $(terraform output -raw aks_resource_group_name) \
     --name $(terraform output -raw postgres_fqdn | cut -d'.' -f1)
   ```

### Liquibase migration fails

**Problem:** "Schema-validation" or migration errors in pod logs

**Solutions:**
1. Check database exists:
   ```bash
   # Get pod shell
   kubectl exec -it <pod-name> -- /bin/sh
   
   # Inside pod, check connection (using Azure AD!)
   nc -zv $POSTGRES_HOST 5432
   ```

2. View Liquibase logs:
   ```bash
   kubectl logs <pod-name> | grep -i liquibase
   ```

3. Verify changelogs are correct (already tested locally!)

### GitHub Actions disabled and forgot to re-enable

**Problem:** Pushed code but workflow doesn't run

**Solution:**
1. Go to repo → Settings → Actions → General
2. Select "Allow all actions and reusable workflows"
3. Save
4. Push again or trigger manually

---

## 📊 Comparison: Before vs After

| Aspect | Old Approach | New Approach |
|--------|-------------|--------------|
| **GitHub Secrets** | 9 secrets | **1 secret** 🎉 |
| **Manual steps** | Many (SP creation, ACR creds, etc.) | Minimal (terraform apply) |
| **PostgreSQL auth** | Username + password | **Passwordless** via Managed Identity |
| **Secret rotation** | Regular (every 90 days) | Once/year (service principal only) |
| **Infrastructure changes** | Update 9 secrets manually | **Automatic** via Terraform |
| **Setup complexity** | High | **Low** |
| **Security** | Passwords in GitHub | **No passwords** where possible |
| **Debugging** | Hard (secrets hidden) | **Easy** (values in logs) |
| **Team collaboration** | Complex handoff | **Simple** (just share Terraform access) |
| **Environment setup** | Different secrets per env | **Same secret**, different Terraform workspace |

---

## ✅ Checklist

Use this for your deployment:

- [ ] Liquibase implemented ✅ (already done!)
- [ ] GitHub Actions disabled temporarily
- [ ] `terraform apply` completed successfully
- [ ] Service principal JSON obtained (`terraform output -raw azure_credentials_json`)
- [ ] AZURE_CREDENTIALS secret added to GitHub (only 1 secret!)
- [ ] GitHub Actions re-enabled
- [ ] Code pushed to trigger deployment
- [ ] Workflow "build-and-push" job succeeded
- [ ] Workflow "deploy" job succeeded
- [ ] All 4 pods running in AKS
- [ ] Liquibase migrations executed successfully
- [ ] Services responding to health checks
- [ ] No PostgreSQL password errors (using Managed Identity!)

---

## 🎉 Summary

### What Makes This Deployment Special

**1. Minimal Secrets (89% Reduction!)**
- From 9 secrets → 1 secret
- Only AZURE_CREDENTIALS needed
- Everything else fetched dynamically

**2. Passwordless Database Authentication**
- No PostgreSQL passwords anywhere
- Azure AD authentication via Workload Identity
- More secure, less to manage

**3. Infrastructure as Code**
- Service principal created by Terraform
- Managed identity created by Terraform
- All permissions configured automatically
- No manual Azure portal clicks

**4. Dynamic Configuration**
- ACR name fetched at runtime
- AKS name fetched at runtime
- PostgreSQL host fetched at runtime
- No hardcoded values in workflow

**5. Production-Ready**
- Liquibase for database migrations
- Workload Identity for pod authentication
- Proper role assignments
- Audit trail via Terraform

### What You've Achieved

✅ **Full automation** - Infrastructure and deployment fully automated  
✅ **Best practices** - Following Azure and Kubernetes security guidelines  
✅ **Team-friendly** - Simple setup, easy to replicate  
✅ **Maintainable** - Single source of truth (Terraform)  
✅ **Secure** - Minimal secrets, passwordless where possible  

---

## 📖 Next Steps

Your deployment is **fully configured and ready**! Just:

1. **Disable GitHub Actions** (via web UI)
2. **Run** `terraform apply -var-file=dev.tfvars`
3. **Get** `terraform output -raw azure_credentials_json`
4. **Add** as AZURE_CREDENTIALS secret in GitHub
5. **Re-enable** GitHub Actions
6. **Push** code
7. **Watch** the magic happen! 🚀

---

## 📚 Additional Documentation

- **AUTOMATED_CREDENTIAL_ROTATION.md** - 🔄 Zero-downtime automatic secret rotation
- **MINIMAL_SECRETS_DEPLOYMENT.md** - Detailed explanation of minimal secrets approach
- **AUTOMATED_SERVICE_PRINCIPAL.md** - Service principal automation details
- **LIQUIBASE_COMPLETE.md** - Liquibase implementation summary
- **DOCKER_LOCAL_SETUP.md** - Local development with Docker PostgreSQL

---

**Your deployment is now enterprise-grade: automated, secure, and maintainable! 🎉**
